# About

GraphicsProt is a simple and straightforward graphics prototyping(programming) framework for C++ and Vulkan, featuring sample implementations.

- Windows & Mac cross platform
- C++ & GLSL code only (no editor)
- game engine like easy API, short code
- prototyping purpose only (currently not support for production)
- including sample implementations for my research / hobby purpose (this is main focus)

# Installation

- Windows : CMake and shader compilation by executing Generate_Windows_VS2022.bat (more details later)
- Mac : CMake and Visual Studio Code (more details later)

# Dependencies

C++(17), [Vulkan](https://www.vulkan.org/), [GLFW](https://github.com/glfw/glfw), [ImGUI](https://github.com/ocornut/imgui), [stb_image](https://github.com/nothings/stb/blob/master/stb_image.h), [glm](https://github.com/g-truc/glm)

# Samples

## Minimum Code
![image](https://github.com/mushe/GraphicsProt/assets/26865534/af7f4c0c-8673-47ce-8c76-0b11312417b2)
minimum code to draw .obj
- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/01_Minimum
- 3D model credit
"Steven Universe House" by Zypheos : https://sketchfab.com/3d-models/steven-universe-house-ea77c49785fc4802b697bde0f7cfda8f

----

## Gerstner Waves

![GIF 1-1-2024 11-32-54 PM](https://github.com/mushe/GraphicsProt/assets/26865534/a2ceeaff-14d0-46bf-90ce-20f1a58a5a45)

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/02_GerstnerWaves
- Demo : https://www.youtube.com/watch?v=WFtOAE4n0-w

Gerstner Waves is a famous algorithm that draws pseudo ocean

background texture is generated by DreamStudio

- References

(1) GPU Gems Chapter 1. Effective Water Simulation from Physical Models

https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models

(2) 【ポケットモンスター スカーレット・バイオレット】 パルデア地方を描き出す――見た目の仕組みを徹底解説！

https://cedec.cesa.or.jp/2023/session/detail/s64242ce14adbf

----

## Grayscale (post process)
![image](https://github.com/mushe/GraphicsProt/assets/26865534/56326ed8-e1cf-43c0-abee-7f4968bb7182)

simple grayscale post process implementation

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/03_GrayScale

- References

(1) Grayscale - Wikipedia

https://en.wikipedia.org/wiki/Grayscale

----

## Grass
![GIF 1-2-2024 4-39-25 AM](https://github.com/mushe/GraphicsProt/assets/26865534/9110e6e3-2f9d-42bb-8e81-b3f5bb641f4b)

grass texture is generated by DreamStudio

floor texture is created at Test Grid Generator : https://wahooney.itch.io/texture-grid-generator

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/04_Grass

- References

(1) UnrelVFXCollection - Grass

https://github.com/mushe/UnrealVFXCollection/tree/main/Content/VFXCollections/Grass

----

## Normal Mapping from Texture (diffuse and specular)
![image](https://github.com/mushe/GraphicsProt/assets/26865534/61cc17e5-70c7-4061-841d-36ff009bacf0)

normal map texture is generated at https://cpetry.github.io/NormalMap-Online/

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/05_NormalMapping

----

## Instancing
![image](https://github.com/mushe/GraphicsProt/assets/26865534/15319254-48e9-4305-8828-32e25a306b94)

Instancing is a standard technique for drawing many objects
- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/06_Instancing

----

## Drawing Basic 2D Shape (Instancing)
![GIF 1-6-2024 7-26-12 AM](https://github.com/mushe/GraphicsProt/assets/26865534/b8816ae3-ef0e-43bb-99b5-486023ac4842)

drawing shapes(rect, circle, triangle, line) with a handy API

```cpp
engine->BeginRenderToScreen();

// call between BeginRenderToScreen and EndRenderToScreen
ShapeDrawer::Rect(Vec2(0.25), Vec2(0.25)); // position, scale, (color)
ShapeDrawer::Circle(Vec2(0.75), Vec2(0.25), Vec4(1)); // position, scale, (color)
ShapeDrawer::Line(Vec2(0.625, 0.125), Vec2(0.875, 0.375)); // start, end, (width), (color)
ShapeDrawer::Triangle(Vec2(0.25, 0.75), Vec2(0.25), Vec2(0.25)); // position, direction, scale, (color)

engine->EndRenderToScreen();
```

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/07_Shape

----

## Maze
![image](https://github.com/mushe/GraphicsProt/assets/26865534/94fcb486-5c3f-4458-9cbd-cc37efe8a66f)

procedurally generated maze
- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/08_Maze

- References

(1) 自動生成迷路

https://www5d.biglobe.ne.jp/~stssk/maze/make.html

## Pi estimation by Monte Carlo Method
![3C1DC5BA-B8A7-4251-A990-367E2AF38716_4_5005_c](https://github.com/mushe/GraphicsProt/assets/26865534/5e997b68-fe96-4fe3-860c-408e2ca8b0d8)

Plot points at random against some location in the circle circumscribed by the square. Then the number of points in the circle / number of points in the square = π / 4, which gets closer as the number of points increases. Using this logic, we can approximate pi.

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/PiCalculation

## Chromatic Aberration (post process)
![53912266-41D9-457A-951F-80BC759CF54B_4_5005_c](https://github.com/mushe/GraphicsProt/assets/26865534/1109b4c8-858f-42dc-8a7c-143c5b926fe8)

Shift the RGB color pick position for each RGB individually

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/ChromaticAberration

## Halftone by probability (post process)
![8D3490EC-AF7E-4953-9B3B-20749E7EBAC4_4_5005_c](https://github.com/mushe/GraphicsProt/assets/26865534/687f1656-f789-4a39-85f0-7c3fee9b3462)

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/HalfTone
- References

(1) コンピュータグラフィックス編集委員会, "コンピュータグラフィックス", 画像情報教育振興協会, 2008, p199.

## Posterization (post process)
![3D6C996B-6BF7-42A2-AC2E-6D304BEA0B64_4_5005_c](https://github.com/mushe/GraphicsProt/assets/26865534/fe6b0a2e-e37d-4cbb-bc5c-730d2cf209de)

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/Posterization
- Image Credit : https://pixabay.com/photos/mountain-nature-landscape-picture-646389/
- References

(1) コンピュータグラフィックス編集委員会, "コンピュータグラフィックス", 画像情報教育振興協会, 2008, p221.

## Pseudo Color (post process)
![9068EB43-1FC8-4C3A-85E7-133C2074DFC9_4_5005_c](https://github.com/mushe/GraphicsProt/assets/26865534/8b336eeb-0b55-4cce-9522-9c17f9762631)

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/PseudoColor
- Image Credit : https://en.wikipedia.org/wiki/File:Milwaukee_City_Hall_Old_Public_Domain_Photo.jpg
- References

(1) コンピュータグラフィックス編集委員会, "コンピュータグラフィックス", 画像情報教育振興協会, 2008, p224.

## Sepia (post process)
![3B0E17EB-0AC4-488A-9198-3F420D76CFA0_4_5005_c](https://github.com/mushe/GraphicsProt/assets/26865534/da8e9544-5fed-40fb-96e3-5d6d069763e6)

nostalgic post process

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/Sepia
- References

(1) How to convert a color image into sepia image - Image Processing Project - dyclassroom

https://dyclassroom.com/image-processing-project/how-to-convert-a-color-image-into-sepia-image

## Text Rendering (instancing)
![0A78F898-67FA-47FE-B343-FCB74D8D192C_4_5005_c](https://github.com/mushe/GraphicsProt/assets/26865534/0651942e-f5fd-4ce5-86c5-9bae6370f23e)

handy text rendering API

- Code : https://github.com/mushe/GraphicsProt/tree/main/src/Samples/TextRender
- Font Credit :  https://levien.com/type/myfonts/inconsolata.html

# Usage Examples

## minimum code

```cpp
#include "Core/Engine.h"

int main()
{
    // engine initialization
    auto engine = Engine::Init();

    // create mesh from obj
    auto mesh = Mesh::FromOBJ("../Models/StevenUNiverseRoom/StevenUNiverseRoom.obj");
    mesh->SetPosition(Vec3(0, -1.0f, 0));
    mesh->SetRotation(Vec3(0));
    mesh->SetScale(Vec3(0.1f));

    // load texture
    auto tex = Texture::FromPNG("../Models/StevenUNiverseRoom/StevenUNiverseRoom.png");

    // create material by shader and texture
    auto mat = Material::Create("Standard.vert", "UnlitTexture.frag", { tex });

    // set material to mesh
    mesh->SetMaterial(mat);

    // create camera for object rendering
    Camera camera;

    // main rendering loop
    while (engine->Running())
    {
        engine->BeginFrame(); // must be called at the beginning of every frame

        // input handling
        if (Input::KeyDown(KeyCode::Escape)) engine->Quit();

        // camera orbital control with mouse
        OrbitalControl::Update(camera);

        // object rendering to screen by camera
        engine->BeginRenderToScreen();
        mesh->Draw(camera);
        engine->EndRenderToScreen();

        engine->EndFrame(); // must be called at the end of every frame
    }

    engine->Terminate();
}

```

## object rendering to RenderTexture

```cpp
auto rt = RenderTarget::Create(1920, 1080);
...
rt->BeginRenderToTexture();
mesh->Draw(camera);
rt->EndRenderToTexture();
```

## draw(Blit) material to RenderTexture

post process etc.. implemented using this feature

```cpp

engine->BlitToRenderTarget(material, rt);
...
engine->BlitToScreen(material);
```

## GLSL shader loading

```cpp
// create material by shader and texture
auto mat = Material::Create("standard.vert", "unlitTexture.frag", { tex });
```

## pass uniform buffer to shader

```cpp
PostProcessUBO ubo{};
material->SetUniformBufferData(&ubo);
```

## .obj loading

```cpp
auto mesh = Mesh::FromOBJ("../path/to/obj/X.obj");
```

## .png loading

```cpp
auto tex = Texture::FromPNG("../path/to/png/X.png");
```

## GUI

imgui accessor

```jsx
engine->OnGUI([&]()
{
    GUI::Float(scale_, "scale", 0.1f);
		GUI::FloatSlider(colorLerp, "colorLerp", 0.0f, 1.0f);
    GUI::Color(color_, "color_");
    GUI::Vector(g_objPos, "g_objPos", 0.01f);
    GUI::VectorSlider(lightDir, "lightDir", -1.0f, 1.0f);
});
```

## key and mouse input

```cpp
// key handling
if (Input::KeyDown(KeyCode::Escape)) engine->Quit();

// mouse drag delta
glm::vec2 rightMouseDrag = Input::LeftMouseDrag();

// mouse sheel delta
float wheelVel = Input::MouseWheelDelta();
```

## orbital camera control with mouse

```cpp
Camera camera;
OrbitalControl::Update(camera);
```

## text drawing
```cpp
// text, position, scale, color
Text("ABC", Vec2(0.5f, 0.5f), 1.0f, Vec4(1,1,1,1));
```

## 2d shape drawing
```cpp
engine->BeginRenderToScreen();

// call between BeginRenderToScreen and EndRenderToScreen
ShapeDrawer::Rect(Vec2(0.25), Vec2(0.25)); // position, scale, (color)
ShapeDrawer::Circle(Vec2(0.75), Vec2(0.25), Vec4(1)); // position, scale, (color)
ShapeDrawer::Line(Vec2(0.625, 0.125), Vec2(0.875, 0.375)); // start, end, (width), (color)
ShapeDrawer::Triangle(Vec2(0.25, 0.75), Vec2(0.25), Vec2(0.25)); // position, direction, scale, (color)

engine->EndRenderToScreen();
```
